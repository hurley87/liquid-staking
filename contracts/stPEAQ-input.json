{
  "language": "Solidity",
  "sources": {
    "contracts/stPEAQ.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title stPEAQ Token Contract\n * @notice This contract implements a staked version of the PEAQ token with rebasing functionality\n * @dev Inherits from ERC20 and Ownable contracts\n */\ncontract stPEAQ is ERC20, ERC20Permit, Ownable, Pausable {\n    uint256 private _scalingFactor = 1e18;\n    uint256 private _totalUnderlying;\n    address public stakingContract;\n\n    event ScalingFactorUpdated(uint256 oldFactor, uint256 newFactor);\n    event StakingContractUpdated(address oldContract, address newContract);\n\n    modifier onlyStakingContract() {\n        require(msg.sender == stakingContract, \"Caller is not the staking contract\");\n        _;\n    }\n\n    /**\n     * @notice Constructor initializes the stPEAQ token and sets the staking contract address\n     * @param _stakingContract Address of the staking contract that will manage this token\n     */\n    constructor(address _stakingContract) \n        ERC20(\"Staked PEAQ\", \"stPEAQ\")\n        ERC20Permit(\"Staked PEAQ\")\n        Ownable(msg.sender) \n    {\n        stakingContract = _stakingContract;\n    }\n\n    /**\n     * @notice Updates the staking contract address\n     * @dev Only callable by the contract owner\n     * @param _stakingContract New staking contract address\n     */\n    function setStakingContract(address _stakingContract) external onlyOwner {\n        require(_stakingContract != address(0), \"Invalid address\");\n        stakingContract = _stakingContract;\n        emit StakingContractUpdated(stakingContract, _stakingContract);\n    }\n\n    /**\n     * @notice Updates the scaling factor used for token calculations\n     * @dev Only callable by the contract owner\n     * @param newScalingFactor New scaling factor value (must be greater than 0)\n     */\n    function setScalingFactor(uint256 newScalingFactor) external onlyOwner {\n        require(newScalingFactor > 0, \"Scaling factor must be positive\");\n        uint256 oldFactor = _scalingFactor;\n        _scalingFactor = newScalingFactor;\n        emit ScalingFactorUpdated(oldFactor, newScalingFactor);\n    }\n\n    /**\n     * @notice Mints new stPEAQ tokens\n     * @dev Only callable by the staking contract\n     * @param to Address to receive the minted tokens\n     * @param amount Amount of underlying tokens to mint (will be scaled)\n     */\n    function mint(address to, uint256 amount) external onlyStakingContract whenNotPaused {\n        require(to != address(0), \"Cannot mint to zero address\");\n        uint256 scaledAmount = (amount * 1e18) / _scalingFactor;\n        _mint(to, scaledAmount);\n        _totalUnderlying += amount;\n    }\n\n    /**\n     * @notice Burns stPEAQ tokens\n     * @dev Only callable by the staking contract\n     * @param from Address to burn tokens from\n     * @param amount Amount of underlying tokens to burn (will be scaled)\n     */\n    function burn(address from, uint256 amount) external onlyStakingContract whenNotPaused {\n        uint256 scaledAmount = (amount * 1e18) / _scalingFactor;\n        _burn(from, scaledAmount);\n        // Ensure _totalUnderlying doesn't go below the minimum required for rebasing\n        if (amount >= _totalUnderlying) {\n            _totalUnderlying = 1; // Keep minimal value to allow future rebasing\n        } else {\n            _totalUnderlying -= amount;\n        }\n    }\n\n    /**\n     * @notice Performs a rebase operation to adjust token balances\n     * @dev Only callable by the staking contract\n     * @param newTotalUnderlying New total amount of underlying tokens\n     */\n    function rebase(uint256 newTotalUnderlying) external onlyStakingContract {\n        require(totalSupply() > 0, \"Cannot rebase with zero supply\");\n        require(newTotalUnderlying > 0, \"New total must be positive\");\n        // Remove the strict increase requirement\n        _scalingFactor = (newTotalUnderlying * 1e18) / totalSupply();\n        _totalUnderlying = newTotalUnderlying;\n    }\n\n    /**\n     * @notice Returns the balance of tokens for a given account\n     * @dev Overrides ERC20 balanceOf to apply scaling factor\n     * @param account Address to check balance for\n     * @return uint256 Scaled balance of the account\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        uint256 scaledBalance = super.balanceOf(account);\n        uint256 adjustedBalance = scaledBalance * _scalingFactor;\n        return adjustedBalance / 1e18;\n    }\n\n    /**\n     * @notice Returns the total supply of tokens\n     * @dev Overrides ERC20 totalSupply to reflect the scaled supply\n     * @return uint256 Scaled total supply\n     */\n    function totalSupply() public view override returns (uint256) {\n        return (_totalUnderlying * 1e18) / _scalingFactor;\n    }\n\n    /**\n     * @notice Returns the current scaling factor\n     * @return uint256 Current scaling factor\n     */\n    function getScalingFactor() external view returns (uint256) {\n        return _scalingFactor;\n    }\n\n    /**\n     * @notice Returns the total amount of underlying PEAQ tokens\n     * @return uint256 Total underlying PEAQ\n     */\n    function getTotalUnderlying() external view returns (uint256) {\n        return _totalUnderlying;\n    }\n\n    /**\n     * @notice Converts stPEAQ amount to underlying PEAQ amount\n     * @param stPeaqAmount Amount of stPEAQ tokens\n     * @return uint256 Equivalent amount of underlying PEAQ tokens\n     */\n    function getUnderlyingAmount(uint256 stPeaqAmount) external view returns (uint256) {\n        return (stPeaqAmount * _scalingFactor) / 1e18;\n    }\n\n    /**\n     * @notice Converts PEAQ amount to stPEAQ amount\n     * @param peaqAmount Amount of PEAQ tokens\n     * @return uint256 Equivalent amount of stPEAQ tokens\n     */\n    function getStPeaqAmount(uint256 peaqAmount) external view returns (uint256) {\n        return (peaqAmount * 1e18) / _scalingFactor;\n    }\n\n    /// @notice Pauses all token transfers and operations\n    /// @dev Can only be called by the contract owner\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract, allowing transfers and operations\n    /// @dev Can only be called by the contract owner\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}
